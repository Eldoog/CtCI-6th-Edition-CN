# Chapter 7 | 面向对象的设计

面向对象（Object-oriented）的设计问题要求候选人能草拟出实现技术问题或现实对象的类和方法。这些问题会让面试官对你的编码风格有一个深入的了解。

这些问题与其说是关于重复设计模式，不如说是关于说明您了解如何创建优雅的、可维护的面向对象代码。在这类问题上的糟糕表现可能会引发严重的危险信号（red flag）。

### 如何处理
无论对象是物理项还是技术任务，都可以用类似的方法处理面向对象的设计问题。下面的方法可以很好地解决许多问题。

#### 步骤1：处理歧义

面向对象设计（OOD）问题通常是有意含糊不清的，以便测试你是否会做出假设，或者是否会要求澄清问题。 毕竟，如果一个开发人员只是编写代码，而不理解她所期望创建的内容，将浪费公司的时间和金钱，并有可能会产生更严重的问题。

当被问及面向对象的设计问题时，你应该询问谁将使用它（who）以及它们将如何使用它（how）。根据实际问题，你甚至可以通过“六个W”来澄清，即：who、what、where、when、how、why。

例如，假设你被要求描述一个咖啡机的面向对象设计。这看起来很简单，对吧？ 实则并不完全是这样。

你的咖啡机可能是一台工业机器，设计用于大型餐厅，每小时为数百名顾客提供服务，并制作十种不同类型的咖啡产品。或者它可能是一台非常简单的机器，专为老年人设计用于制作简单的黑咖啡。这些用例将显著影响你的设计。

#### 步骤2：定义核心对象

既然我们已经理解了我们在设计什么，那么我们应该考虑系统中的“核心对象”是什么。例如，假设我们被要求为一家餐厅进行面向对象的设计。我们的核心对象可能是诸如 Table、Guest、Party、Order、Meal、Employee、Server 和 Host 之类的东西。

#### 步骤3：分析关系

或多或少地确定了我们的核心对象之后，我们现在要分析对象之间的关系。 哪些对象是其他对象的成员？是否有对象从其他对象继承？关系是多对多还是一对多？

例如，在餐厅（Restaurant）问题中，我们可能会提出以下设计：

- Party 上应该有很多 Guest。
- Server 和 Host 继承自 Employee。
- 每个 Table 都只有一个 Party，但是每个 Party 可以有多个 Table 。
- 该 Restaurant 只有一个 Host 。

在这里要非常小心——你可能会很容易做出错误的假设。例如，一张 Table 可能有多个 Party （在一些餐厅前卫的“公共餐桌”中很常见）。你应该跟你的面试官确认需要将设计做到何种通用程度。

#### 步骤4：探究对象的行为

此时，你应该已经有了你面向对象的设计的基本轮廓。剩下的就是考虑对象将采取的关键行为（key actions）以及它们之间是如何相互关联的。你可能会发现之前遗漏了一些对象，因此将需要更新设计。

例如，一群人（Party）走进餐厅（Restaurant），其中一位顾客（Guest）向主人（Host）要了一张桌子（Table）。主人（Host）查看预定单（Reservation），如果存在预订，则给这群人（Party）分配给一张桌子（Table）。否则，这群客人（Party）将被添加到列表的末尾。当一组客人（Party）离开时，桌子（Table）被释放并分配给列表中的新的一群人（Party） 。

### 设计模式
因为面试官想测试的是你的能力而不是你的知识，所以设计模式大多超出了面试的范围。然而，单例（Singleton）和工厂方法（Factory Method）设计模式在面试中经常会被用到，所以我们将在此简单做下介绍。

实际上设计模式的种类比本书可能会提及的要多得多。如果你想提高这方面的软件工程技能的，最好还是法是挑选一本专门针对这个领域的书。

要小心，不要陷入不断尝试为特定问题找到“正确”设计模式的陷阱。你应该创建适用于该问题的设计。在某些情况下，它可能是一个既定的设计模式，但在许多其他情况下则不是。

#### 单例类
单例模式（Singleton pattern）确保一个类只有一个实例，并确保通过应用程序访问该实例。如果你有一个只有一个实例的“全局”对象，它可能非常有用。例如，我们可以向下面这样实现 Restaurant类，使它只有一个 Restaurant 类的实例。

```java
1 	public class Restaurant {
2 		private static Restaurant _instance = null;
3 		protected Restaurant() { ... }
4 		public static Restaurant getlnstance() {
5 			if (_instance == null) {
6 				_instance = new Restaurant();
7 			}
8 			return _instance;
9 		}
10 	}
```

应该指出的是，许多人不喜欢单例设计模式，甚至称它为“反模式（anti-pattern）”。其中一个原因是它可能会干扰单元测试。

#### 工厂方法

工厂方法（Factory Method）提供了一个用于创建类实例的接口，其子类决定实例化哪个类。 你可以在 Creator 类是抽象类的情况下实现此操作，而无需为工厂方法提供实现。或者，你可以将 Creator 类作为具体类，并为工厂方法提供实现。在这种情况下，工厂方法将接受一个参数，该参数表示要实例化哪个类。

```java
1 	public class CardGame {
2 		public static CardGame createCardGame(GameType type) {
3 			if (type == GameType.Poker) {
4 				return new PokerGame();
5 			} else if (type == GameType.BlackJack) {
6 				return new BlackJackGame();
7 			}
8 			return null;
9 		}
10 	}
```

------

### Interview Questions

------

